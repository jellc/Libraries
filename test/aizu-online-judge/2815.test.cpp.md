---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: src/graph/directed/flow/base.hpp
    title: Flow Graph
  - icon: ':heavy_check_mark:'
    path: src/graph/directed/flow/min_cost_flow.hpp
    title: Minimum Cost Flow
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/problems/2815
    links:
    - https://onlinejudge.u-aizu.ac.jp/problems/2815
  bundledCode: "#line 1 \"test/aizu-online-judge/2815.test.cpp\"\n#define PROBLEM\
    \ \"https://onlinejudge.u-aizu.ac.jp/problems/2815\"\n\n#include <iostream>\n\n\
    #line 2 \"src/graph/directed/flow/min_cost_flow.hpp\"\n\n/**\n * @file min_cost_flow.hpp\n\
    \ * @brief Minimum Cost Flow\n * @date 2021-01-15\n *\n *\n */\n\n#include <algorithm>\n\
    #include <optional>\n#include <queue>\n\n#line 2 \"src/graph/directed/flow/base.hpp\"\
    \n\n/**\n * @file base.hpp\n * @brief Flow Graph\n * @date 2021-01-15\n *\n *\n\
    \ */\n\n#include <cassert>\n#include <vector>\n\nnamespace workspace {\n\ntemplate\
    \ <class Cap, class Cost = void> class flow_graph {\n public:\n  class adjacency;\n\
    \  using value_type = adjacency;\n  using reference = adjacency &;\n  using const_reference\
    \ = adjacency const &;\n  using container_type = std::vector<value_type>;\n  using\
    \ size_type = typename container_type::size_type;\n\n  class unweighted_edge {\n\
    \   public:\n    size_type src, dst;\n    Cap cap;\n    unweighted_edge *rev;\n\
    \n    unweighted_edge() = default;\n\n    unweighted_edge(size_type src, size_type\
    \ dst, const Cap &cap,\n                    unweighted_edge *rev)\n        : src(src),\
    \ dst(dst), cap(cap), rev(rev) {\n      assert(!(cap < static_cast<Cap>(0)));\n\
    \    }\n\n    const Cap &flow(const Cap &f = 0) { return cap -= f, rev->cap +=\
    \ f; }\n\n    unweighted_edge make_rev() { return {dst, src, 0, this}; }\n  };\n\
    \n  class weighted_edge : public unweighted_edge {\n   public:\n    Cost cost;\n\
    \n    weighted_edge() = default;\n\n    weighted_edge(size_type src, size_type\
    \ dst, const Cap &cap,\n                  const Cost &cost, weighted_edge *rev)\n\
    \        : unweighted_edge(src, dst, cap, rev), cost(cost) {}\n\n    weighted_edge\
    \ make_rev() {\n      return {unweighted_edge::dst, unweighted_edge::src, 0, -cost,\
    \ this};\n    }\n  };\n\n  using edge = typename std::conditional<std::is_void<Cost>::value,\n\
    \                                         unweighted_edge, weighted_edge>::type;\n\
    \n  class adjacency {\n   public:\n    using value_type = edge;\n    using reference\
    \ = edge &;\n    using const_reference = edge const &;\n    using pointer = edge\
    \ *;\n    using const_pointer = const edge *;\n\n    adjacency() : first(new edge[1]),\
    \ iter(first), last(first + 1) {}\n    ~adjacency() { delete[] first; }\n\n  \
    \  template <class... Args> reference emplace(Args &&... args) {\n      if (iter\
    \ == last) {\n        size_type len(last - first);\n        edge *nfst = iter\
    \ = new edge[len << 1];\n        for (edge *p{first}; p != last; ++p, ++iter)\n\
    \          p->rev->rev = iter, *iter = *p;\n        delete[] first;\n        first\
    \ = nfst;\n        last = iter + len;\n      }\n      return *iter++ = edge(args...);\n\
    \    }\n\n    reference operator[](size_type i) {\n      assert(i < size());\n\
    \      return *(first + i);\n    }\n    const_reference operator[](size_type i)\
    \ const {\n      assert(i < size());\n      return *(first + i);\n    }\n\n  \
    \  size_type size() const { return iter - first; }\n\n    pointer begin() { return\
    \ first; }\n    const_pointer begin() const { return first; }\n\n    pointer end()\
    \ { return iter; }\n    const_pointer end() const { return iter; }\n\n   protected:\n\
    \    pointer first, iter, last;\n  };\n\n  /**\n   * @brief Construct a new flow\
    \ base object\n   *\n   * @param n Number of vertices\n   */\n  flow_graph(size_type\
    \ n = 0) : graph(n) {}\n\n  flow_graph(const flow_graph &other) : graph(other.size())\
    \ {\n    for (size_type node = 0; node != size(); ++node)\n      for (edge cp\
    \ : other[node])\n        if (cp.src == node) {\n          edge rcp = *cp.rev;\n\
    \          cp.rev->src = nil;\n          edge &ref = graph[node].emplace(cp);\n\
    \          rcp.rev = &ref;\n          ref.rev = &graph[cp.dst].emplace(rcp);\n\
    \        } else\n          cp.rev->rev->src = node;\n  }\n\n  flow_graph &operator=(const\
    \ flow_graph &rhs) {\n    if (this != &rhs) graph.swap(flow_graph(rhs).graph);\n\
    \    return *this;\n  }\n\n  /**\n   * @return Number of vertices.\n   */\n  size_type\
    \ size() const { return graph.size(); }\n\n  reference operator[](size_type node)\
    \ {\n    assert(node < size());\n    return graph[node];\n  }\n\n  const_reference\
    \ &operator[](size_type node) const {\n    assert(node < size());\n    return\
    \ graph[node];\n  }\n\n  typename container_type::iterator begin() { return graph.begin();\
    \ }\n\n  typename container_type::iterator end() { return graph.end(); }\n\n \
    \ typename container_type::const_iterator begin() const {\n    return graph.begin();\n\
    \  }\n\n  typename container_type::const_iterator end() const { return graph.end();\
    \ }\n\n  template <class... Args>\n  typename adjacency::reference add_edge(size_type\
    \ src, size_type dst,\n                                         Args &&... args)\
    \ {\n    assert(src < size());\n    assert(dst < size());\n    auto &ref = graph[src].emplace(src,\
    \ dst, args..., nullptr);\n    ref.rev = &graph[dst].emplace(ref.make_rev());\n\
    \    return ref;\n  }\n\n protected:\n  constexpr static size_type nil = -1;\n\
    \  container_type graph;\n};\n\n}  // namespace workspace\n#line 16 \"src/graph/directed/flow/min_cost_flow.hpp\"\
    \n\nnamespace workspace {\n\n/**\n * @brief Successive Shortest Path Algorithm.\n\
    \ *\n * @tparam Cap Capacity type\n * @tparam Cost Cost type\n * @tparam Density_tag\
    \ Whether the graph is dense.\n */\ntemplate <class Cap, class Cost, bool Density_tag\
    \ = false>\nclass min_cost_flow : public flow_graph<Cap, Cost> {\n  using base\
    \ = flow_graph<Cap, Cost>;\n  using base::nil;\n\n public:\n  using edge = typename\
    \ base::edge;\n  using size_type = typename base::size_type;\n\n protected:\n\
    \  Cost current, abs_sum;\n  std::vector<Cap> b;\n  std::vector<Cost> p;\n\n \
    \ void copy(const min_cost_flow &other) {\n    current = other.current;\n    abs_sum\
    \ = other.abs_sum;\n    b = other.b;\n    p = other.p;\n  }\n\n  void Dijkstra(std::vector<edge\
    \ *> &last) {\n    const Cost infty(abs_sum + 1);\n    std::vector<Cost> newp(size(),\
    \ infty);\n    if constexpr (Density_tag) {  // O(V^2)\n      std::vector<bool>\
    \ used(size());\n      for (size_type src{}; src != size(); ++src) {\n       \
    \ if (static_cast<Cap>(0) < b[src]) {\n          used[src] = true;\n         \
    \ newp[src] = 0;\n          for (edge &e : base::graph[src]) {\n            if\
    \ (static_cast<Cap>(0) < b[e.dst]) continue;\n            if (static_cast<Cap>(0)\
    \ < e.cap && e.cost < newp[e.dst]) {\n              newp[e.dst] = e.cost;\n  \
    \            last[e.dst] = &e;\n            }\n          }\n        }\n      }\n\
    \      for (;;) {\n        size_type src{nil};\n        Cost sp{infty};\n    \
    \    for (size_type node{}; node != size(); ++node) {\n          if (used[node]\
    \ || newp[node] == infty) continue;\n          Cost dist{newp[node] - p[node]};\n\
    \          if (dist < sp) {\n            sp = dist;\n            src = node;\n\
    \          }\n        }\n        if (src == nil) break;\n        used[src] = true;\n\
    \        for (edge &e : base::graph[src]) {\n          if (static_cast<Cap>(0)\
    \ < e.cap && newp[src] + e.cost < newp[e.dst]) {\n            newp[e.dst] = newp[src]\
    \ + e.cost;\n            last[e.dst] = &e;\n          }\n        }\n      }\n\
    \    } else {  // O((V + E)logV)\n      struct sp_node {\n        size_type id;\n\
    \        Cost dist;\n        sp_node(size_type id, Cost dist) : id(id), dist(dist)\
    \ {}\n        bool operator<(const sp_node &rhs) const { return rhs.dist < dist;\
    \ }\n      };\n      std::priority_queue<sp_node> q;\n      for (size_type src{};\
    \ src != size(); ++src)\n        if (static_cast<Cap>(0) < b[src]) {\n       \
    \   newp[src] = 0;\n          for (edge &e : base::graph[src])\n            if\
    \ (!(static_cast<Cap>(0) < b[e.dst]) &&\n                static_cast<Cap>(0) <\
    \ e.cap && newp[e.dst] > e.cost) {\n              q.emplace(e.dst, (newp[e.dst]\
    \ = e.cost) - p[e.dst]);\n              last[e.dst] = &e;\n            }\n   \
    \     }\n      while (!q.empty()) {\n        auto [src, ndist] = q.top();\n  \
    \      q.pop();\n        if (ndist + p[src] != newp[src]) continue;\n        for\
    \ (edge &e : base::graph[src])\n          if (static_cast<Cap>(0) < e.cap && newp[e.dst]\
    \ > newp[src] + e.cost) {\n            q.emplace(e.dst, (newp[e.dst] = newp[src]\
    \ + e.cost) - p[e.dst]);\n            last[e.dst] = &e;\n          }\n      }\n\
    \    }\n    p.swap(newp);\n  }\n\n public:\n  using base::size;\n\n  /**\n   *\
    \ @brief Construct a new object\n   *\n   * @param n Number of vertices.\n   */\n\
    \  min_cost_flow(size_type n = 0)\n      : base::flow_graph(n), current(0), abs_sum(0),\
    \ b(n), p(n) {}\n\n  min_cost_flow(const min_cost_flow &other) : base::flow_graph(other)\
    \ {\n    copy(other);\n  }\n\n  min_cost_flow &operator=(const min_cost_flow &other)\
    \ {\n    base::operator=(other);\n    copy(other);\n    return *this;\n  }\n\n\
    \  // infinity capatity\n  // edge *add_edge(size_type src, size_type dst, const\
    \ Cost &cost);\n\n  /**\n   * @brief Add an edge to the graph.\n   *\n   * @param\
    \ src Source\n   * @param dst Destination\n   * @param cap Capacity\n   * @param\
    \ cost Cost\n   * @return Reference to the edge.\n   */\n  typename base::adjacency::reference\
    \ add_edge(size_type src, size_type dst,\n                                   \
    \            const Cap &cap,\n                                               const\
    \ Cost &cost) {\n    assert(src != dst);\n    if (cost < static_cast<Cost>(0))\
    \ {\n      b[src] -= cap;\n      b[dst] += cap;\n      current += cap * cost;\n\
    \      abs_sum -= cap * cost;\n      return base::add_edge(dst, src, cap, -cost);\n\
    \    }\n    abs_sum += cap * cost;\n    return base::add_edge(src, dst, cap, cost);\n\
    \  }\n\n  /**\n   * @brief Add an edge to the graph.\n   *\n   * @param src Source\n\
    \   * @param dst Destination\n   * @param lower Lower bound of flow\n   * @param\
    \ upper Upper bound of flow\n   * @param cost Cost\n   * @return Reference to\
    \ the edge.\n   */\n  typename base::adjacency::reference add_edge(size_type src,\
    \ size_type dst,\n                                               const Cap &lower,\n\
    \                                               const Cap &upper,\n          \
    \                                     const Cost &cost) {\n    assert(!(upper\
    \ < lower));\n    b[src] -= lower;\n    b[dst] += lower;\n    current += lower\
    \ * cost;\n    return add_edge(src, dst, upper - lower, cost);\n  }\n\n  /**\n\
    \   * @brief Increase the balance of a node.\n   *\n   * @param node\n   * @param\
    \ vol\n   */\n  void supply(size_type node, const Cap &vol) {\n    assert(node\
    \ < size());\n    b[node] += vol;\n  }\n\n  /**\n   * @brief Decrease the balance\
    \ of a node.\n   *\n   * @param node\n   * @param vol\n   */\n  void demand(size_type\
    \ node, const Cap &vol) { supply(node, -vol); }\n\n  /**\n   * @param node\n \
    \  * @return Balance of the node\n   */\n  Cap balance(size_type node) { return\
    \ b[node]; }\n\n  /**\n   * @return Cost of current flow.\n   */\n  Cost cost()\
    \ const { return current; }\n\n  /**\n   * @brief Run Successive Shortest Path\
    \ Algorithm.\n   *\n   * @return Whether a balanced flow exists.\n   */\n  bool\
    \ flow() {\n    for (bool aug = true; aug;) {\n      aug = false;\n      std::vector<edge\
    \ *> last(size());\n      Dijkstra(last);\n      std::vector<bool> shut(size());\n\
    \      for (size_type dst{}; dst != size(); ++dst) {\n        if (b[dst] < static_cast<Cap>(0)\
    \ and last[dst]) {\n          Cap resid{-b[dst]};\n          size_type src{dst},\
    \ block{nil};\n          while (last[src] && !shut[src]) {\n            if (!(resid\
    \ < last[src]->cap)) resid = last[block = src]->cap;\n            src = last[src]->src;\n\
    \          }\n          if (shut[src])\n            block = src;\n          else\
    \ {\n            if (!(resid < b[src])) resid = b[block = src];\n            for\
    \ (edge *e{last[dst]}; e; e = last[e->src]) {\n              e->cap -= resid;\n\
    \              e->rev->cap += resid;\n            }\n            b[src] -= resid;\n\
    \            b[dst] += resid;\n            current += p[dst] * resid;\n      \
    \      aug = true;\n          }\n          if (~block) {\n            for (size_type\
    \ node{dst};; node = last[node]->src) {\n              shut[node] = true;\n  \
    \            if (node == block) break;\n            }\n          }\n        }\n\
    \      }\n    }\n    return std::none_of(begin(b), end(b), [](const Cap &s) {\n\
    \      return s < static_cast<Cap>(0) || static_cast<Cap>(0) < s;\n    });\n \
    \ }\n};\n\n}  // namespace workspace\n#line 6 \"test/aizu-online-judge/2815.test.cpp\"\
    \n\nint main() {\n  using namespace workspace;\n\n  int n, m, k;\n  std::cin >>\
    \ n >> m >> k;\n  const int total = n + m + 3;\n  const int dst = total - 1;\n\
    \  const int dst2 = total - 2;\n  const int dst3 = total - 3;\n  min_cost_flow<int,\
    \ int> mcf(total);\n  mcf.supply(dst, -n);\n  mcf.add_edge(dst2, dst, n, 0);\n\
    \  mcf.add_edge(dst3, dst, n - k, 0);\n  for (int i = 0; i < n; ++i) {\n    mcf.supply(i,\
    \ 1);\n    std::cin >> k;\n    mcf.add_edge(i, dst2, 1, -k);\n  }\n  for (int\
    \ j = 0; j < m; j++) {\n    for (int i = 0; i < n; i++) {\n      std::cin >> k;\n\
    \      mcf.add_edge(i, j + n, 1, -k);\n    }\n  }\n  for (int j = 0; j < m; j++)\
    \ {\n    std::cin >> k;\n    mcf.add_edge(j + n, dst3, k, 0);\n  }\n  assert(mcf.flow());\n\
    \  std::cout << -mcf.cost() << \"\\n\";\n}\n"
  code: "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/2815\"\n\n#include\
    \ <iostream>\n\n#include \"src/graph/directed/flow/min_cost_flow.hpp\"\n\nint\
    \ main() {\n  using namespace workspace;\n\n  int n, m, k;\n  std::cin >> n >>\
    \ m >> k;\n  const int total = n + m + 3;\n  const int dst = total - 1;\n  const\
    \ int dst2 = total - 2;\n  const int dst3 = total - 3;\n  min_cost_flow<int, int>\
    \ mcf(total);\n  mcf.supply(dst, -n);\n  mcf.add_edge(dst2, dst, n, 0);\n  mcf.add_edge(dst3,\
    \ dst, n - k, 0);\n  for (int i = 0; i < n; ++i) {\n    mcf.supply(i, 1);\n  \
    \  std::cin >> k;\n    mcf.add_edge(i, dst2, 1, -k);\n  }\n  for (int j = 0; j\
    \ < m; j++) {\n    for (int i = 0; i < n; i++) {\n      std::cin >> k;\n     \
    \ mcf.add_edge(i, j + n, 1, -k);\n    }\n  }\n  for (int j = 0; j < m; j++) {\n\
    \    std::cin >> k;\n    mcf.add_edge(j + n, dst3, k, 0);\n  }\n  assert(mcf.flow());\n\
    \  std::cout << -mcf.cost() << \"\\n\";\n}\n"
  dependsOn:
  - src/graph/directed/flow/min_cost_flow.hpp
  - src/graph/directed/flow/base.hpp
  isVerificationFile: true
  path: test/aizu-online-judge/2815.test.cpp
  requiredBy: []
  timestamp: '2021-01-18 04:25:33+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/aizu-online-judge/2815.test.cpp
layout: document
redirect_from:
- /verify/test/aizu-online-judge/2815.test.cpp
- /verify/test/aizu-online-judge/2815.test.cpp.html
title: test/aizu-online-judge/2815.test.cpp
---
